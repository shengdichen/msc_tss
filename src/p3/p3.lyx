#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass amsart
\use_default_options true
\master ../main.lyx
\begin_removed_modules
theorems-ams
\end_removed_modules
\begin_modules
eqs-within-sections
figs-within-sections
tabs-within-sections
theorems-ams-chap-bytype
theorems-ams-extended-chap-bytype
algorithm2e
customHeadersFooters
enumitem
logicalmkup
todonotes
\end_modules
\maintain_unincluded_children no
\language english
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "default" "Libertinus Serif"
\font_sans "default" "Avenir LT Std"
\font_typewriter "default" "Source Code Pro"
\font_math "auto" "default"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 93
\use_microtype true
\use_dash_ligatures true
\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing other 1.09
\use_hyperref true
\pdf_title "Sample Thesis"
\pdf_author "Shengdi »shc« Chen"
\pdf_subject "Sample Thesis by Shengdi »shc« Chen, supervised by himself"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=black,  frenchlinks=true, citecolor=black, urlcolor=blue, filecolor=blue, pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine biblatex
\cite_engine_type numerical
\biblatex_bibstyle nature
\biblatex_citestyle alphabetic-verb
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 0.75in
\topmargin 0.75in
\rightmargin 0.75in
\bottommargin 1in
\headsep 0.3in
\footskip 0.3in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side right
\quotes_style danish
\dynamic_quotes 1
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tablestyle default
\listings_params "basicstyle={\ttfamily\normalsize},commentstyle={\sffamily},columns=fullflexible,numbers=left,numberstyle={\ttfamily\scriptsize},stepnumber=1,numberblanklines=false,firstline=1,numbersep=9pt,frame=tlb,framexleftmargin=3pt,framextopmargin=2pt,framexbottommargin=1pt,aboveskip={\medskipamount},belowskip={\medskipamount},captionpos=b,floatplacement=tbp,tabsize=4,resetmargins=false,breaklines=true,breakatwhitespace=false,breakautoindent=true,breakindent=0pt,prebreak={...},postbreak={...},extendedchars=true"
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Section
Learning Pipeline
\end_layout

\begin_layout Standard
This section builds upon the previous chapters on PDE models,
 dataset structures,
 as well as masking,
 to build the full learning pipeline of this project,
 covering the process from dataset generation to model evaluation.
\end_layout

\begin_layout Subsection
Network candidates
\begin_inset CommandInset label
LatexCommand label
name "subsec:Network-candidates"

\end_inset


\end_layout

\begin_layout Standard
A critical component of any machine-learning pipeline is the underlying network model.
 This thesis deploys four networks,
 each with its own distinct design motivations and characteristics.
 This section enumerates these four networks and provides a quick overview of their respective properties and configurations as used in this project.
 It should be noted that a thorough run-down of the individual algorithms is not the goal here;
 the interested reader is referred to the referenced papers for deeper investigation.
\end_layout

\begin_layout Subsubsection
FNO
\end_layout

\begin_layout Definition
Structural definition of FNO 
\begin_inset Note Note
status collapsed

\begin_layout Definition
FNO
\end_layout

\begin_deeper
\begin_layout Plain Layout
The Fourier Neural Operator (FNO) is a novel machine learning framework designed to solve partial differential equations (PDEs) efficiently by learning operators in the Fourier domain.
 Traditional neural networks struggle with high-dimensional PDEs due to the curse of dimensionality.
 FNO addresses this by leveraging the Fourier transform to capture global information and spatial correlations more effectively.
\end_layout

\begin_layout Plain Layout
How FNO Works:
\end_layout

\begin_layout Itemize
Input Transformation:
\end_layout

\begin_deeper
\begin_layout Itemize
The input function,
 typically a spatial field,
 is transformed into the Fourier domain using the Fourier transform.
 This step converts the spatial information into frequency components.
\end_layout

\end_deeper
\begin_layout Itemize
Fourier Layer:
\end_layout

\begin_deeper
\begin_layout Itemize
In the Fourier domain,
 the network applies learned complex-valued weights to the Fourier coefficients.
 This layer captures the global interactions of the input features,
 which are challenging for traditional neural networks to model directly in the spatial domain.
\end_layout

\end_deeper
\begin_layout Itemize
Inverse Fourier Transform:
\end_layout

\begin_deeper
\begin_layout Itemize
After processing in the Fourier domain,
 the modified Fourier coefficients are transformed back into the spatial domain using the inverse Fourier transform.
 This step ensures that the output remains in the same domain as the input.
\end_layout

\end_deeper
\begin_layout Itemize
Nonlinear Activation and Stacking:
\end_layout

\begin_deeper
\begin_layout Itemize
The transformed data goes through nonlinear activation functions and can be processed through multiple Fourier layers.
 Each layer consists of a forward Fourier transform,
 weight application in the Fourier domain,
 and an inverse Fourier transform.
\end_layout

\end_deeper
\begin_layout Itemize
Output:
\end_layout

\begin_deeper
\begin_layout Itemize
The final output is a prediction of the solution to the PDE or the next state of the system being modeled.
 The network learns an efficient mapping from the input field to the output field by optimizing the weights in the Fourier layers.
\end_layout

\end_deeper
\begin_layout Itemize
Advantages:
\end_layout

\begin_deeper
\begin_layout Itemize
Efficiency:
 FNO is computationally efficient due to the use of the fast Fourier transform (FFT).
\end_layout

\begin_layout Itemize
Accuracy:
 By working in the Fourier domain,
 FNO captures long-range dependencies and global information effectively.
\end_layout

\begin_layout Itemize
Scalability:
 FNO can handle high-dimensional problems better than traditional methods,
 making it suitable for complex PDEs.
\end_layout

\end_deeper
\begin_layout Itemize
In summary,
 FNO leverages the Fourier transform to learn global representations of spatial fields,
 providing an efficient and scalable approach to solving high-dimensional PDEs.
\end_layout

\end_deeper
\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Plain Layout
Summary:
 The classical development of neural networks has primarily focused on learning mappings between finite-dimensional Euclidean spaces.
 Recently,
 this has been generalized to neural operators that learn mappings between function spaces.
 For partial differential equations (PDEs),
 neural operators directly learn the mapping from any functional parametric dependence to the solution.
 Thus,
 they learn an entire family of PDEs,
 in contrast to classical methods which solve one instance of the equation.
 In this work,
 we formulate a new neural operator by parameterizing the integral kernel directly in Fourier space,
 allowing for an expressive and efficient architecture.
 We perform experiments on Burgers' equation,
 Darcy flow,
 and Navier-Stokes equation.
 The Fourier neural operator is the first ML-based method to successfully model turbulent flows with zero-shot super-resolution.
 It is up to three orders of magnitude faster compared to traditional PDE solvers.
 Additionally,
 it achieves superior accuracy compared to previous learning-based solvers under fixed resolution.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Designed with the philosophy to model PDE operators directly in the continuous space,
 the FNO network 
\begin_inset CommandInset citation
LatexCommand cite
key "fno,fno-neural-operator"
literal "false"

\end_inset

 approaches operator-learning with an attempt to parameterize and learn directly in function space.
 These ambitious goals are,
 however,
 contrasted by its exceedingly simple core design,
 as conceptually captured by the following diagram:
\begin_inset Formula 
\[
\xymatrix{ &  & \underbrace{\;\;\mathcal{F}\rightarrow\mathbf{R}\rightarrow\mathcal{F}^{-1}\;}_{\eqqcolon\text{\;Fourier Layer}}\ar@(r,u)[rd]\\
\text{[IN]}\ar@{-->}[r] & f\left(\mathbf{x}\right)\ar@(u,l)[ru]\ar[rd] &  & +\left(\cdot,\cdot\right)\ar[r]^{\text{D}} & \sigma\left(\cdot\right)\ar@{-->}[r] & \text{[OUT]}\\
 &  & \mathbf{W}\left(\cdot\right)\ar[ru]
}
\]

\end_inset


\end_layout

\begin_layout Standard
FNO has since established itself with its wide application potential in the field,
 in particular,
 as a benchmarking reference for similar competing algorithms,
 as seen in publications such as 
\begin_inset CommandInset citation
LatexCommand cite
key "cno,kno,kno-publish"
literal "false"

\end_inset

.
 Providing an execution acceleration up to three orders of magnitude compared to solver methods from applied mathematics,
 FNO boasts of other striking characteristics including resolution-invariance and mesh-independency,
 all the while escaping the curse of dimensionality 
\begin_inset CommandInset citation
LatexCommand cite
key "fno,fno-neural-operator,operator-learning-intro"
literal "false"

\end_inset

 due to the very nature of its Fourier operations.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
FNO Configuration
\end_layout

\begin_deeper
\begin_layout Standard
For the purpose of concept demonstration,
 this project provides a custom implementation of FNO in addition to including the official implementation by its authors 
\begin_inset CommandInset citation
LatexCommand cite
key "fno,fno-neural-operator"
literal "false"

\end_inset

.
 One striking characteristics of this personal implementation is the requirement of non-channel major dataset orientation,
 where the channels form the last axis of the dataset,
 serving the purpose of demonstration of this particular dataset structure as discussed previously in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Dataset"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_layout Standard
The official FNO implementation by its author(s) 
\begin_inset CommandInset citation
LatexCommand cite
key "fno,fno-neural-operator"
literal "false"

\end_inset

 is shipped as a dependency of this project and used for systematic training for reference purposes.
 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $3$
\end_inset

 Fourier layers are used,
 each with 
\begin_inset Formula $64$
\end_inset

 channels;
\end_layout

\begin_layout Enumerate
for both 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

,
 
\begin_inset Formula $16$
\end_inset

 convolution modes are kept in the Fourier layers.
\end_layout

\begin_layout Standard
The unmentioned parameters inherit the default value as recommended by the author.
 The number of channels for input and output are naturally inferred from the concrete problem.
 For the double-masked Poisson Equation as introduced in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "exa:poisson-mask-double"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the number of channels are 
\begin_inset Formula $4$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

 respectively.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
CNO
\end_layout

\begin_layout Example
CNO
\begin_inset Note Note
status collapsed

\begin_layout Itemize
GPT
\end_layout

\begin_deeper
\begin_layout Itemize
The Continuous Neural Operator (CNO) is an advanced machine learning framework designed to efficiently learn the solutions of partial differential equations (PDEs) from continuous space-time data.
 The CNO extends the capabilities of neural operators by operating directly in the continuous domain,
 making it suitable for high-dimensional and complex PDE problems.
\end_layout

\begin_layout Itemize
Neural Operators:
\end_layout

\begin_deeper
\begin_layout Itemize
Neural operators are a class of machine learning models that learn mappings between function spaces,
 allowing them to approximate the solutions to PDEs.
 The CNO builds upon this concept by focusing on continuous data.
\end_layout

\end_deeper
\begin_layout Itemize
Continuous Framework:
\end_layout

\begin_deeper
\begin_layout Itemize
Unlike traditional neural networks that work on discretized data,
 the CNO operates in the continuous space-time domain.
 This is achieved through the use of integral kernels and continuous layers that can process data without relying on a fixed grid.
\end_layout

\end_deeper
\begin_layout Itemize
Efficient Learning:
\end_layout

\begin_deeper
\begin_layout Itemize
The CNO leverages efficient learning mechanisms that can handle large-scale and high-dimensional data.
 This includes the use of kernel integral operators and advanced neural network architectures that can generalize well across different PDEs.
\end_layout

\end_deeper
\begin_layout Itemize
Applications:
 The CNO is applicable to a variety of PDE-driven problems across physics,
 engineering,
 and other scientific fields.
 Examples include fluid dynamics,
 electromagnetism,
 and materials science,
 where accurate and efficient solution approximations are critical.
\end_layout

\begin_layout Itemize
Advantages:
\end_layout

\begin_deeper
\begin_layout Itemize
Continuity:
 By operating in the continuous domain,
 the CNO can provide more accurate approximations and is not limited by the resolution of discretized data.
\end_layout

\begin_layout Itemize
Scalability:
 The framework is designed to handle high-dimensional problems efficiently,
 making it suitable for complex real-world applications.
\end_layout

\begin_layout Itemize
Generalization:
 The CNO can generalize across different types of PDEs,
 offering a versatile tool for solving a wide range of problems.
\end_layout

\end_deeper
\begin_layout Itemize
In summary,
 the Continuous Neural Operator (CNO) is a powerful extension of neural operators that efficiently learns the solutions of PDEs from continuous space-time data,
 providing high accuracy and scalability for complex and high-dimensional problems.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
For the CNO network as introduced in 
\begin_inset CommandInset citation
LatexCommand cite
key "cno"
literal "false"

\end_inset

 is configured with 
\begin_inset Formula $4$
\end_inset

 layers as specified in its reference implementation.
 The input and output channel counts are adapted for the specific dataset as explained for the FNO model.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Note
CNO configuration
\end_layout

\begin_deeper
\begin_layout Standard
This thesis deploys a custom implementation of the CNO algorithm adapted from the author's official repository
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "GitHub repository"
target "https://github.com/camlab-ethz/ConvolutionalNeuralOperator"
literal "false"

\end_inset

 by CNO's authors
\end_layout

\end_inset

.
 Configurations of the CNO algorithm A personal implementation based on the lecture document (TODO:
 ref) is included in the repository.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="5">
<features booktabs="true" islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\qquad$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#hidden-channels
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#layers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kernel-size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
depth
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computation mode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status open

\begin_layout Plain Layout
JIT
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:network-cno"

\end_inset

Configuration for UNet
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
UNet
\end_layout

\begin_layout Definition
UNet
\begin_inset Note Note
status collapsed

\begin_layout Itemize
summary:
 There is large consent that successful training of deep networks requires many thousand annotated training samples.
 In this paper,
 we present a network and training strategy that relies on the strong use of data augmentation to use the available annotated samples more efficiently.
 The architecture consists of a contracting path to capture context and a symmetric expanding path that enables precise localization.
 We show that such a network can be trained end-to-end from very few images and outperforms the prior best method (a sliding-window convolutional network) on the ISBI challenge for segmentation of neuronal structures in electron microscopic stacks.
 Using the same network trained on transmitted light microscopy images (phase contrast and DIC) we won the ISBI cell tracking challenge 2015 in these categories by a large margin.
 Moreover,
 the network is fast.
 Segmentation of a 512x512 image takes less than a second on a recent GPU.
 The full implementation (based on Caffe) and the trained networks are available at this http URL .
\end_layout

\begin_layout Itemize
summary:
 The u-net is convolutional network architecture for fast and precise segmentation of images.
 Up to now it has outperformed the prior best method (a sliding-window convolutional network) on the ISBI challenge for segmentation of neuronal structures in electron microscopic stacks.
 It has won the Grand Challenge for Computer-Automated Detection of Caries in Bitewing Radiography at ISBI 2015,
 and it has won the Cell Tracking Challenge at ISBI 2015 on the two most challenging transmitted light microscopy categories (Phase contrast and DIC microscopy) by a large margin (See also our annoucement).
\end_layout

\begin_layout Itemize
GPT
\end_layout

\begin_layout Plain Layout
It was introduced by Olaf Ronneberger et al.
 in 2015.
 The architecture is named "UNet" due to its U-shaped structure,
 which consists of a contracting path (encoder) and an expansive path (decoder).
\end_layout

\begin_layout Plain Layout
How UNet Works:
\end_layout

\begin_layout Itemize
Contracting Path (Encoder):
\end_layout

\begin_deeper
\begin_layout Itemize
Convolutional Layers:
 The encoder consists of repeated application of two 3x3 convolutional layers followed by a rectified linear unit (ReLU) and a 2x2 max pooling operation with stride 2 for downsampling.
\end_layout

\begin_deeper
\begin_layout Itemize
Feature Extraction:
 This path captures the context and extracts features by reducing the spatial dimensions while increasing the depth of the feature maps.
\end_layout

\end_deeper
\begin_layout Itemize
Bottleneck:
 The deepest part of the network where the spatial dimensions are the smallest,
 and the most abstract features are learned.
 It usually consists of convolutional layers without downsampling.
\end_layout

\begin_layout Itemize
Expansive Path (Decoder):
\end_layout

\begin_deeper
\begin_layout Itemize
Upsampling:
 Each step in the decoder consists of an upsampling of the feature map followed by a 2x2 convolution ("up-convolution") that halves the number of feature channels,
 a concatenation with the corresponding feature map from the contracting path,
 and two 3x3 convolutions,
 each followed by a ReLU.
\end_layout

\begin_layout Itemize
Combining Features:
 This path combines the spatial information from the upsampled feature maps with the corresponding high-resolution features from the encoder through skip connections.
\end_layout

\end_deeper
\begin_layout Itemize
Output Layer:
 A final 1x1 convolution is used to map the feature maps to the desired number of classes for segmentation.
\end_layout

\begin_layout Itemize
Skip Connections:
 The skip connections from the encoder to the decoder ensure that the network can learn fine-grained details and spatial context,
 improving the accuracy of segmentation.
\end_layout

\begin_layout Itemize
Applications:
\end_layout

\begin_deeper
\begin_layout Itemize
UNet is widely used in medical image segmentation,
 such as tumor detection in MRI scans,
 and other fields where precise segmentation is crucial.
\end_layout

\end_deeper
\begin_layout Plain Layout
In summary,
 UNet's architecture efficiently combines the localization capability of traditional convolutional networks with the context information provided by the encoder-decoder structure,
 making it highly effective for image segmentation tasks.
\end_layout

\begin_layout Section
Excerpt
\end_layout

\begin_layout Plain Layout
The network architecture is illustrated in Figure 1.
 It consists of a contracting
\end_layout

\begin_layout Plain Layout
path (left side) and an expansive path (right side).
 The contracting path follows
\end_layout

\begin_layout Plain Layout
the typical architecture of a convolutional network.
 It consists of the repeated
\end_layout

\begin_layout Plain Layout
application of two 3x3 convolutions (unpadded convolutions),
 each followed by
\end_layout

\begin_layout Plain Layout
a rectified linear unit (ReLU) and a 2x2 max pooling operation with stride 2
\end_layout

\begin_layout Plain Layout
for downsampling.
 At each downsampling step we double the number of feature
\end_layout

\begin_layout Plain Layout
channels.
 Every step in the expansive path consists of an upsampling of the
\end_layout

\begin_layout Plain Layout
feature map followed by a 2x2 convolution (“up-convolution”) that halves the
\end_layout

\begin_layout Plain Layout
number of feature channels,
 a concatenation with the correspondingly cropped
\end_layout

\begin_layout Plain Layout
feature map from the contracting path,
 and two 3x3 convolutions,
 each fol-
\end_layout

\begin_layout Plain Layout
lowed by a ReLU.
 The cropping is necessary due to the loss of border pixels in
\end_layout

\begin_layout Plain Layout
every convolution.
 At the final layer a 1x1 convolution is used to map each 64-
\end_layout

\begin_layout Plain Layout
component feature vector to the desired number of classes.
 In total the network
\end_layout

\begin_layout Plain Layout
has 23 convolutional layers.
\end_layout

\begin_layout Plain Layout
To allow a seamless tiling of the output segmentation map (see Figure 2),
 it
\end_layout

\begin_layout Plain Layout
is important to select the input tile size such that all 2x2 max-pooling operations
\end_layout

\begin_layout Plain Layout
are applied to a layer with an even x- and y-size.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Originally conceived for the purpose of image segmentation,
 UNet 
\begin_inset CommandInset citation
LatexCommand cite
key "unet"
literal "false"

\end_inset

 is designed to is a convolutional neural network architecture designed for image segmentation tasks,
 particularly biomedical image segmentation with localization requirement for the underlying classification problem.
 
\end_layout

\begin_layout Standard
(TODO:
 rewrite this paragraph) Consisting of a contracting encoder and a expanding decoder,
 where the encoder follows the typical CNN architecture,
 to perform a downsampling with stride 
\begin_inset Formula $2$
\end_inset

.
 The encoder then expands step-wise the feature channels to the output cardinality.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Note
UNet configuration
\end_layout

\begin_deeper
\begin_layout Standard
This thesis deploys a custom implementation of the UNet algorithm.
 A personal implementation based on the lecture document (TODO:
 ref) is included in the repository.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="5">
<features booktabs="true" islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\qquad$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#hidden-channels
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#layers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kernel-size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
depth
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
activation-fn
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status open

\begin_layout Plain Layout
relu
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:network-unet"

\end_inset

Configuration for UNet
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
KNO
\end_layout

\begin_layout Definition
KNO
\begin_inset Note Note
status collapsed

\begin_layout Itemize
Summary:
 Numerous physics theories are rooted in partial differential equations (PDEs).
 However,
 the increasingly intricate physics equations,
 especially those that lack analytic solutions or closed forms,
 have impeded the further development of physics.
 Computationally solving PDEs by classic numerical approaches suffers from the trade-off between accuracy and efficiency and is not applicable to the empirical data generated by unknown latent PDEs.
 To overcome this challenge,
 we present KoopmanLab,
 an efficient module of the Koopman neural operator family,
 for learning PDEs without analytic solutions or closed forms.
 Our module consists of multiple variants of the Koopman neural operator (KNO),
 a kind of mesh-independent neural-network-based PDE solvers developed following dynamic system theory.
 The compact variants of KNO can accurately solve PDEs with small model sizes while the large variants of KNO are more competitive in predicting highly complicated dynamic systems govern by unknown,
 high-dimensional,
 and non-linear PDEs.
 All variants are validated by mesh-independent and long-term prediction experiments implemented on representative PDEs (e.g.,
 the Navier-Stokes equation and the Bateman-Burgers equation in fluid mechanics) and ERA5 (i.e.,
 one of the largest high-resolution global-scale climate data sets in earth physics).
 These demonstrations suggest the potential of KoopmanLab to be a fundamental tool in diverse physics studies related to equations or dynamic systems.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The Koopman Lab algorithm is a method for modeling the latent dynamics of complex systems using probabilistic frameworks.
 It leverages Koopman operator theory,
 which provides a linear perspective on the nonlinear dynamics of a system by representing the evolution of observable functions.
 The approach aims to capture and predict the underlying dynamics of high-dimensional,
 nonlinear systems in a computationally efficient manner.
\end_layout

\begin_layout Itemize
Koopman Operator:
 The Koopman operator is a linear operator that acts on the space of observable functions,
 allowing for the representation of nonlinear dynamics in a linear framework.
 This operator facilitates the analysis and prediction of the system's evolution over time.
\end_layout

\begin_layout Itemize
Probabilistic Latent Dynamics:
 The algorithm models the latent dynamics probabilistically.
 This involves learning a latent representation of the system's state space and the corresponding dynamics that evolve over time.
 The probabilistic approach allows for the handling of uncertainty and variability in the data.
\end_layout

\begin_layout Itemize
Learning Framework:
 The Koopman Lab algorithm employs a neural network-based framework to learn the Koopman operator and the latent dynamics simultaneously.
 The neural network is trained to approximate the Koopman operator by minimizing the reconstruction error of the observed data and the prediction error of the latent dynamics.
\end_layout

\begin_layout Itemize
Applications:
 The method is applicable to various domains,
 including fluid dynamics,
 climate modeling,
 and other areas where understanding and predicting complex,
 nonlinear dynamics are crucial.
 The Koopman Lab algorithm provides a powerful tool for capturing the essential features of these systems in a linear,
 yet probabilistic manner.
\end_layout

\begin_layout Itemize
Advantages:
\end_layout

\begin_deeper
\begin_layout Itemize
Efficiency:
 By leveraging the linearity of the Koopman operator,
 the algorithm can efficiently model and predict complex dynamics.
\end_layout

\begin_layout Itemize
Robustness:
 The probabilistic nature of the model allows it to handle noise and uncertainty in the data.
\end_layout

\begin_layout Itemize
Versatility:
 The approach is versatile and can be applied to a wide range of nonlinear systems.
\end_layout

\end_deeper
\begin_layout Itemize
In summary,
 the Koopman Lab algorithm combines Koopman operator theory with probabilistic modeling to effectively capture and predict the latent dynamics of complex systems,
 providing a robust and efficient framework for understanding nonlinear behaviors.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The KNO network as introduced in is conceived to capture behavior of complex evolution.
 A 
\end_layout

\begin_layout Standard
Designed to tackle non-linear and possibly non-autonomous dynamic systems,
 the KNO 
\begin_inset CommandInset citation
LatexCommand cite
key "kno,kno-publish"
literal "false"

\end_inset

,
 acronym for Koopman Neural Operator,
 aims to models these latent dynamics with a theoretically infinite-dimensional linear Koopman operator.
 Specifically,
 after linearizing the dynamics in some appropriate observation space of choice,
 a mapping shall be created to capture all possible observations of the underlying dynamic system,
 which is then iteratively updated linearly to capture the evolution behavior.
 KNO is verified by its authors in domains such as fluid dynamics and earth physics,
 providing a probabilistic approach with fast run-time.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Implementation and Configuration
\end_layout

\begin_deeper
\begin_layout Standard
This thesis provides a custom implementation of the KNO algorithm as described above.
 The encoding and decoding steps are configured as concatenations of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
pytorch
\end_layout

\end_inset

's builtin convolution and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Tanh
\end_layout

\end_inset

 operators.
 Further values chosen for network construction are listed in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:network-kno"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 The reader is encouraged to study the implementation of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
KNO2d
\end_layout

\end_inset

 class in module 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
src/deepl/kno.py
\end_layout

\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# /src/deepl/kno.py
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class KNO2d(torch.nn.Module):
\end_layout

\begin_layout Plain Layout

    ...
  # implementation detail not shown
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:network-kno"

\end_inset

KNO implementation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features booktabs="true" islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\qquad$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hidden-channels
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
layers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:network-kno"

\end_inset

Configuration for the KNO network.
 Implementation details available in class 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
KNO2d
\end_layout

\end_inset

 in source module 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
src/deepl/kno.py
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
Network Factory
\end_layout

\begin_layout Standard
The four algorithms as introduced above constitute the network pool of this thesis.
 A separate 
\begin_inset Quotes xld
\end_inset

factory
\begin_inset Quotes xrd
\end_inset

 is written to provide a concise construction interface for all networks,
 configuring each to a reasonable default in the settings of the project.
 The call-site is relieved of extra configuration details of each individual network,
 enabling a clean abstraction for network construction:
 simply calling 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Network.all()
\end_layout

\end_inset

 returns a generator for the entire network pool of the current 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
LHS
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
RHS
\end_layout

\end_inset

 channel widths requirement.
\end_layout

\begin_layout Standard
The network factory also contains utilities for automatic save-load management.
 The interested reader shall study the source for more details.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# /src/deepl/factory.py
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Network:
\end_layout

\begin_layout Plain Layout

    @classmethod
\end_layout

\begin_layout Plain Layout

    def all(
\end_layout

\begin_layout Plain Layout

        cls,
 dim_lhs:
 int = 8,
 dim_rhs:
 int = 1
\end_layout

\begin_layout Plain Layout

    ) -> Generator["Network",
 None,
 None]:
\end_layout

\begin_layout Plain Layout

        yield cls.fno(dim_lhs,
 dim_rhs)
\end_layout

\begin_layout Plain Layout

        yield cls.cno(dim_lhs,
 dim_rhs)
\end_layout

\begin_layout Plain Layout

        yield cls.kno(dim_lhs,
 dim_rhs)
\end_layout

\begin_layout Plain Layout

        yield cls.unet(dim_lhs,
 dim_rhs)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def save(self,
 path:
 pathlib.Path) -> None:
\end_layout

\begin_layout Plain Layout

        ...
  # implementation detail not shown
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def load(self,
 path:
 pathlib.Path) -> None:
\end_layout

\begin_layout Plain Layout

        ...
  # implementation detail not shown
\end_layout

\end_inset


\end_layout

\begin_layout Section
Prediction Model
\end_layout

\begin_layout Subsection
Masked Dataset
\end_layout

\begin_layout Standard
This section enumerates the PDE models investigated in this project alongside the construction of their respective datasets for the learning pipeline.
 The common procedure for such dataset construction is described as follows:
\end_layout

\begin_layout Definition
Dataset structure
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this context,
 the channels matrix-like components,
 otherwise referred to as 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
channels
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A dataset of size 
\begin_inset Formula $i$
\end_inset

 contains 
\begin_inset Formula $i$
\end_inset

 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
instances
\end_layout

\end_inset

,
 where each instance 
\begin_inset Formula $z_{i}$
\end_inset

 is composed of two channel-groups:
 the 
\begin_inset Formula $\texttt{LHS}_{i}$
\end_inset

 and 
\begin_inset Formula $\texttt{RHS}_{i}$
\end_inset

 group,
 acronyms for 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
left
\end_layout

\end_inset

 and 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
right
\end_layout

\end_inset

 hand-side respectively:
\begin_inset Formula 
\[
\text{Dataset}\coloneqq\left\{ \begin{alignedat}{2}\overbrace{\qquad\quad\;\;\;}^{\text{instance}} &  &  & \overbrace{\qquad\qquad\quad}^{\text{ch. group}}\\
z_{i-1}\quad & \coloneqq &  & \quad\;\;\;\:\cdots\\
z_{i}\quad & \coloneqq & \; & \;\:\left\langle \begin{alignedat}{1}\;\; & \texttt{LHS}_{i}\\
 & \texttt{RHS}_{i}
\end{alignedat}
\right.\\
z_{i+1}\quad & \coloneqq &  & \quad\;\;\;\:\cdots
\end{alignedat}
\right.
\]

\end_inset

such that the prediction of some network 
\begin_inset Formula $\text{NN}$
\end_inset

 as introduced in the previous chapter can be formulated as follows:
\begin_inset Formula 
\[
\begin{alignedat}{3} & \; & \text{NN}\left(\texttt{LHS}\right) & \longrightarrow & \; & \;\;\,\hat{\texttt{RHS}}\\
\Longrightarrow &  & \text{error} & \,\,\simeq &  & \left\Vert \;\hat{\texttt{RHS}}-\texttt{RHS}\;\right\Vert 
\end{alignedat}
\]

\end_inset

Note that the formulation of the error-term is deliberately vague:
 this is studied more rigorously in the upcoming sections.
\end_layout

\begin_layout Standard
Both channel-groups are,
 as the name suggests,
 a concatenation of multiple channels,
 which typically fall into two categories:
\end_layout

\begin_layout Itemize
those specific to the particular PDE model at hand,
 aka the 
\begin_inset Quotes xld
\end_inset

PDE-channels
\begin_inset Quotes xrd
\end_inset

 
\begin_inset Formula $\mathbf{C}^{\text{PDE}}$
\end_inset

,
 including the solution 
\begin_inset Formula $u_{i}$
\end_inset

 of the PDE itself,
\end_layout

\begin_layout Itemize
those common to the underlying space grid,
 the 
\begin_inset Quotes xld
\end_inset

grid-channels
\begin_inset Quotes xrd
\end_inset

 
\begin_inset Formula $\mathbf{C}^{\text{x}}$
\end_inset

 such as the grid coordinates 
\begin_inset Formula $x_{1,2\cdots}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The following sections explain the constituents of these PDE and grid channels,
 before introducing the construction of the masked dataset for learning and evaluation.
\end_layout

\begin_layout Subsubsection
Grid channels
\end_layout

\begin_layout Standard
One shall note that the coordinates matrices 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 in the proposition above bear no subscript to indicate index 
\begin_inset Formula $i$
\end_inset

.
 This is intentional,
 as the coordinates are constant across all instances of the dataset and require thus no re-computation during the generation procedure.
 This observation is further developed in the following:
\end_layout

\begin_layout Definition
Members of grid-channels 
\begin_inset Formula $\mathbf{C}^{\text{x}}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Channels related to the grid-coordinates 
\begin_inset Formula $\mathbf{C}^{\text{x}}$
\end_inset

 as used in this project are composed of the following six components:
\begin_inset Formula 
\[
\mathbf{C}^{\text{x}}\coloneqq\underbrace{\;\;\;x_{1},x_{2}\;\;\;}_{\text{coord}}\;,\;\,\underbrace{\;\sin\left(x_{1}\right),\sin\left(x_{2}\right),\cos\left(x_{1}\right),\cos\left(x_{2}\right)\;}_{4\times\;\;\text{trig}\left(\text{coord}\right)}
\]

\end_inset

where the first two channels correspond to the raw coordinates of the (two-dimensional) spatial grid,
 and the ensuing four represent these coordinates after applying value-wise trigonometry operations 
\begin_inset Formula $\sin\left(\star\right)$
\end_inset

 and 
\begin_inset Formula $\cos\left(\star\right)$
\end_inset

.
\end_layout

\begin_layout Standard
As observed above,
 these grid-channels are constant for any specific spatial grid and can be saved as such via pre-computation.
 This property is further taken advantage of in (TODO)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
PDE channels
\end_layout

\begin_layout Definition
PDE-channels 
\begin_inset Formula $\mathbf{C}^{\text{PDE}}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Apparently,
 the PDE-channels are provided by the underlying PDE model.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:channels-pde"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 enumerates all the channels specific to the three PDEs of interest of this thesis.
 
\begin_inset Float table
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features booktabs="true" islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="right" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prototype
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\qquad$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Channels 
\begin_inset Formula $\mathbf{C}^{\text{PDE}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Poisson
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $u$
\end_inset

,
 
\begin_inset Formula $f$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Heat Equation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="right" valignment="middle" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $u_{t=0}$
\end_inset

,
 
\begin_inset Formula $u_{t=T}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wave Equation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="right" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:channels-pde"

\end_inset

Masking Targets
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Recalling the previous code Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:dataset-raw"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 one recognizes that that the method
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@abc.abstractmethod
\end_layout

\begin_layout Plain Layout

DatasetPDE.solve_instance() -> Sequence[torch.Tensor]
\end_layout

\end_inset

serves as the key implementation detail of a PDE prototype to provide the PDE-channels relevant to the PDE at hand.
 Unsurprisingly,
 the method is marked as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
abstract
\end_layout

\end_inset

,
 requiring overload from subclasses.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsection
Dataset Setup
\begin_inset CommandInset label
LatexCommand label
name "subsec:Dataset-Setup"

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Itemize
preparation:
 pre knowledge:
\end_layout

\begin_deeper
\begin_layout Itemize
grid (space,
 time if needed)
\end_layout

\begin_layout Itemize
split count
\end_layout

\end_deeper
\begin_layout Itemize
assembly
\end_layout

\begin_deeper
\begin_layout Itemize
generate dataset-specific channels:
\end_layout

\begin_deeper
\begin_layout Itemize
generate raw dataset,
 which requires at least the space grid,
 and,
 depending on the particular PDE model,
 the time grid as well
\end_layout

\end_deeper
\begin_layout Itemize
append grid-specific channels:
 constant
\end_layout

\begin_deeper
\begin_layout Itemize
raw coordinates
\end_layout

\begin_layout Itemize
trigonometric coordinates
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
normalize
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the structure of the dataset seen above,
 the construction of the dataset is detailed as follows:
\end_layout

\begin_layout Definition
Dataset construction
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the case of the two-dimensional space of this thesis,
 
\begin_inset Formula $z_{i}$
\end_inset

 consists thus at least of the following three channels,
 each corresponding to a two-dimensional matrix:
\begin_inset Formula 
\[
z_{i}\coloneqq\Bigl(\overbrace{\;\;\;u_{i},\,\cdots\;\;\;}^{\mathbf{C}^{\text{PDE}}},\;\underbrace{\;x_{1},x_{2},\,\cdots\;}_{\mathbf{C}^{\text{x}}}\Bigr)
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
All available PDE-channels generated by the PDE prototype are divided into two categories:
 those targeted for masking,
 and those kept 
\begin_inset Quotes xld
\end_inset

as-is
\begin_inset Quotes xrd
\end_inset

 without masking.
 Notation-wise,
 this leads to two mutually exclusive sub-groups 
\begin_inset Formula $\mathbf{C}^{\text{PDE-m}}$
\end_inset

 and 
\begin_inset Formula $\mathbf{C}^{\text{PDE-r}}$
\end_inset

 (r as in 
\begin_inset Quotes xld
\end_inset


\begin_inset Flex Emph
status open

\begin_layout Plain Layout
r
\end_layout

\end_inset

aw
\begin_inset Quotes xrd
\end_inset

):
\begin_inset Formula 
\[
\left\{ \begin{alignedat}{2}\mathbf{C}^{\text{PDE-m}}\cup\mathbf{C}^{\text{PDE-r}} & \equiv & \; & \mathbf{C}^{\text{PDE}}\\
\mathbf{C}^{\text{PDE-m}}\cap\mathbf{C}^{\text{PDE-r}} & \eqqcolon &  & \diameter
\end{alignedat}
\right.
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\texttt{LHS}$
\end_inset

 channel-group is constructed as a three-fold concatenation:
 the 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
masked
\end_layout

\end_inset

 target-group,
 the raw-group and the grid group.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\texttt{LHS}\coloneqq\biggl(\underbrace{\overbrace{\phantom{{\displaystyle \prod}}m_{1}^{\text{mask}},\,\cdots\;\;\;\;}^{\mathbf{C}^{\text{PDE-m, mask}}},\;\overbrace{\phantom{{\displaystyle \prod}}r_{1},\,\cdots\;\;\;\;}^{\mathbf{C}^{\text{PDE-r}}}}_{\mathbf{C}^{\text{PDE}}},\;\underbrace{\;x_{1},x_{2},\,\cdots\;}_{\mathbf{C}^{\text{x}}}\biggr)
\]

\end_inset


\end_layout

\begin_layout Standard
On the other hand,
 the 
\begin_inset Formula $\texttt{RHS}$
\end_inset

 channel-group contains the 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
unmasked
\end_layout

\end_inset

 target-group as 
\begin_inset Quotes xld
\end_inset

truth
\begin_inset Quotes xrd
\end_inset

 for the network:
\begin_inset Formula 
\[
\texttt{RHS}\coloneqq\Bigl(\overbrace{\;\;\;m_{1},\,\cdots\;\;\;}^{\mathbf{C}^{\text{PDE-m}}}\Bigr)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Masking targets
\end_layout

\begin_deeper
\begin_layout Standard
The masking targets are listed in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:masking-targets"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="6">
<features booktabs="true" islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PDE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\qquad$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{1}^{\text{st}}$
\end_inset

 target
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{2}^{\text{nd}}$
\end_inset

 target
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Poisson eq.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $u$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Heat eq.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $u_{t=T}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $u_{t=0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wave eq.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:masking-targets"

\end_inset

Masking Targets
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
Generation
\end_layout

\begin_deeper
\begin_layout Standard
The following diagram captures the dataset generation procedure:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{ & \text{ch}^{\text{PDE}}\ar[rd]^{\text{C}}\\
\text{grid}\ar[ru]^{\text{A}}\ar[rd]_{\text{B}} &  & \mathds{D}^{\dagger}\ar[r]^{\text{D}} & \mathds{D}^{\ddagger}\ar[r]^{\text{E}} & *+[F]{\mathds{D}}\\
 & \text{ch}^{\text{grid}}\ar[ru]_{\text{C}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
In step A,
 the (raw) dataset generation routine is called upon to generate 
\begin_inset Formula $i$
\end_inset

 instances of PDE-channels on the chosen spatial and optionally temporal grid,
 and the grid-related channels are fetched trivially in step B.
 These channels are then assembled by the procedure previously seen in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Dataset"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 in step C to form the first fully-shaped dataset 
\begin_inset Formula $\mathds{D}^{\dagger}$
\end_inset

 in the sense of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
pytorch
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
After normalizing the dataset in step D to obtain 
\begin_inset Formula $\mathds{D}^{\ddagger}$
\end_inset

,
 the masking procedure is applied to produce the final 
\begin_inset Formula $\mathds{D}$
\end_inset

 primed for the learning pipeline.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Note
Shape of dataset
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Some algorithms requires a flattened layout of all channel matrices,
 i.e.,
 each channel now has shape 
\begin_inset Formula $4096$
\end_inset

 instead of 
\begin_inset Formula $64\times64$
\end_inset

,
 the official FNO repo refers to this dataset shape as 
\begin_inset Quotes xld
\end_inset

pixel
\begin_inset Quotes xrd
\end_inset

.
 This is,
 however,
 not required by any of the aforementioned algorithms of this project and is thus not implemented.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Since each component of 
\begin_inset Formula $z_{i}$
\end_inset

 is a two-dimensional matrix as representation of the space-grid,
 
\begin_inset Formula $z_{i}$
\end_inset

 itself thus contains one more dimension to indicate the number of these two-dimensional matrices.
 In the minimal example of 
\begin_inset Formula $z_{i}\coloneqq\left(u_{i},x_{1,i},x_{2,i}\right)$
\end_inset

 as proposed above,
 this extra dimension will have the value 
\begin_inset Formula $3$
\end_inset

.
 Consequently,
 a dataset of 
\begin_inset Formula $i$
\end_inset

 of these 
\begin_inset Formula $z_{i}$
\end_inset

 instances is four-dimensional.
\end_layout

\begin_layout Standard
Following standard dataset format,
 the first dimension denotes the number of instances.
 There exists,
 however,
 no standfast rule concerning the ordering of the remaining three dimensions.
 Out of the six
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Number of possible permutations of 
\begin_inset Formula $3$
\end_inset

 elements
\end_layout

\end_inset

 total ordering possibilities,
 two of them are generally acceptable.
 Continuing with the minimal example above with the space-grid as defined in 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:Space-mesh"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 these two orderings yield respectively:
\begin_inset Formula 
\[
\text{dataset-shape}\doteq\left\langle \begin{alignedat}{2} & \: & \Bigl[i,64,64,3\Bigr]\\
 &  & \Bigl[i,3,64,64\Bigr]
\end{alignedat}
\right.
\]

\end_inset

As an example,
 the FNO 
\begin_inset CommandInset citation
LatexCommand cite
key "fno,fno-neural-operator"
literal "false"

\end_inset

 implementation included in this project's repository accepts the first ordering,
 while the CNO 
\begin_inset CommandInset citation
LatexCommand cite
key "cno"
literal "false"

\end_inset

 implementation expects the second.
\end_layout

\begin_layout Standard
also require The official FNO repository 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Given a dataset as prepared with the procedure in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Dataset-Setup"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and one of the networks as enumerated in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Network-candidates"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the prediction model of masked learning can now be presented.
 In this thesis,
 two principle variants are studied:
 the single and the double-mask model.
 This section describes these two models with instructions on their respective setup.
\end_layout

\begin_layout Subsubsection
Single (Solution-) masking
\end_layout

\begin_layout Standard
As the primary artifact of PDE learning is the solution 
\begin_inset Formula $u$
\end_inset

,
 the immediate idea is to apply masks to 
\begin_inset Formula $u$
\end_inset

 itself to form one extra channel of the left-hand side for training.
 In the case of the Heat and Wave Equations,
 the solution would be the 
\begin_inset Formula $u_{T}$
\end_inset

.
\end_layout

\begin_layout Standard
The masking candidates
\end_layout

\begin_layout Standard
Each individual PDE raw dataset must indicate the channels for masking in order of their appearance,
 i.e.,
 the first index will be masked in single masking mode,
 whereas the first and the second index will be masked in double mask mode.
\end_layout

\begin_layout Standard
This is captured in the following definition:
\begin_inset Formula 
\[
\left\{ \begin{alignedat}{2}\texttt{LHS}_{i} & \simeq & \; & \Bigl(i,\left(6+\text{\#channels}\right),64,64\Bigr)\\
\texttt{RHS}_{i} & \simeq &  & \Bigl(i,1,64,64\Bigr)
\end{alignedat}
\right.
\]

\end_inset


\begin_inset Formula 
\[
\left\{ \begin{alignedat}{2}\texttt{LHS}_{i} & \simeq & \; & \Bigl(i,\left(6+\text{\#channels}\right),64,64\Bigr)\\
\texttt{RHS}_{i} & \simeq &  & \Bigl(i,2,64,64\Bigr)
\end{alignedat}
\right.
\]

\end_inset


\end_layout

\begin_layout Definition
Dataset (TODOOO:
 rewrite)
\end_layout

\begin_deeper
\begin_layout Standard
Conforming to 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
pytorch
\end_layout

\end_inset

's 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Dataset
\end_layout

\end_inset

 API,
 each instance of a dataset is provided as:
\begin_inset Formula 
\[
\left\{ \begin{alignedat}{2}\texttt{LHS}_{i} & \coloneqq & \; & \Bigl[u_{i}^{\text{mask}},f_{i},x_{1},x_{2}\Bigr]\\
\texttt{RHS}_{i} & \coloneqq &  & \Bigl[\,u_{i}\,\Bigr]
\end{alignedat}
\right.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Dataset for the Poisson Equation
\end_layout

\begin_deeper
\begin_layout Standard
For the Poisson equation,
 the solver provides each instance of source 
\begin_inset Formula $f_{i}$
\end_inset

 and exact solution 
\begin_inset Formula $u_{i}$
\end_inset

 as a tuple:
\begin_inset Formula 
\[
\text{solver}\longrightarrow\left(u_{i},f_{i}\right)
\]

\end_inset

which is then masked with a masking algorithm conforming to specifications in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Masking"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

:
\begin_inset Formula 
\[
u_{i}\longrightarrow u_{i}^{\text{mask}}
\]

\end_inset

For the Poisson equation discretized spatially as described above,
 the dimensions of these components are easily observed as:
\begin_inset Formula 
\[
\left\{ \begin{alignedat}{2}\texttt{LHS}_{i} & \simeq & \; & \Bigl(i,8,64,64\Bigr)\\
\texttt{RHS}_{i} & \simeq &  & \Bigl(i,1,64,64\Bigr)
\end{alignedat}
\right.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
Prediction
\end_layout

\begin_deeper
\begin_layout Standard
The model evaluates the prediction 
\begin_inset Formula $\hat{u}_{i}$
\end_inset

 as follows:
\begin_inset Formula 
\[
\begin{alignedat}{2}\Bigl(u_{i}^{\text{mask}},f_{i},x_{1},x_{2}\Bigr) & \stackrel{\text{model}}{\longrightarrow} & \; & \hat{u}_{i}\end{alignedat}
\]

\end_inset


\end_layout

\begin_layout Standard
Using the prototypical 
\begin_inset Formula $L^{2}$
\end_inset

-residual,
 the loss is thus understood as:
\begin_inset Formula 
\[
\begin{alignedat}{2}\text{Loss} & = &  & \mathop{\sum_{i}\left\{ \text{Res}_{i}\right\} }\\
 & \stackrel{L^{2}}{\equiv} &  & \mathop{\sum_{i}\Bigl\{\bigl|\,\hat{u}_{i}-u_{i}\bigr|_{2}\Bigr\}}
\end{alignedat}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
Multi-masking
\end_layout

\begin_layout Standard
Apart from the main learning target solution 
\begin_inset Formula $u$
\end_inset

,
 other components of the dataset can be subject to masking as well.
 This notion of 
\begin_inset Quotes xld
\end_inset

multi-masking
\begin_inset Quotes xrd
\end_inset

 is introduced in this section with the Poisson Equation as case study:
\end_layout

\begin_layout Example
Multi-masking on the Poisson Equation 
\begin_inset CommandInset label
LatexCommand label
name "exa:poisson-mask-double"

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The model evaluates the prediction 
\begin_inset Formula $\hat{u}_{i}$
\end_inset

 as follows:
\begin_inset Formula 
\[
\begin{alignedat}{2}\Bigl(u_{i}^{\text{mask}},f_{i}^{\text{mask}},x_{1},x_{2}\Bigr) & \stackrel{\text{model}}{\longrightarrow} & \; & \Bigl(\hat{u}_{i},\hat{f}_{i}\Bigr)\end{alignedat}
\]

\end_inset

The loss as introduced previously is now enriched with the hyper-parameter 
\begin_inset Formula $\lambda$
\end_inset

 to balance the two masked channels:
\begin_inset Formula 
\[
\begin{alignedat}{2}\text{Loss} & = &  & \mathop{\sum_{i}\left\{ \text{Res}_{i}\right\} }\\
 & \stackrel{L^{2}}{\equiv} &  & \mathop{\sum_{i}\Bigl\{\bigl|\,\hat{u}_{i}-u_{i}\bigr|_{2}+\lambda\bigl|\,\hat{f}_{i}-f_{i}\bigr|_{2}\Bigr\}}
\end{alignedat}
\]

\end_inset

In this thesis,
 the 
\begin_inset Formula $\lambda$
\end_inset

 is chosen as:
\begin_inset Formula 
\[
\lambda\coloneqq0.7
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Prediction Model
\begin_inset Note Note
status collapsed

\begin_layout Subsubsection
Learning
\end_layout

\begin_layout Enumerate
dataset
\end_layout

\begin_layout Enumerate
pick prediction model:
\end_layout

\begin_deeper
\begin_layout Enumerate
loss function
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Definition
Dataset splits
\end_layout

\begin_deeper
\begin_layout Standard
Following common etiquette of machine-learning 
\begin_inset CommandInset citation
LatexCommand cite
key "ml-elem-stats-learning,ml-murphy,stats-wasserman"
literal "false"

\end_inset

,
 the datasets for training and testing are mutually exclusive.
 More specifically,
 a 6-to-1-to-1 split is used to generate the splits:
\begin_inset Formula 
\[
\left\{ \begin{alignedat}{2}i_{\text{train}} & \coloneqq & \; & 1800\\
i_{\text{valid}} & \coloneqq &  & 300\\
i_{\text{eval}} & \coloneqq &  & 300
\end{alignedat}
\right.
\]

\end_inset

As usual,
 the testing dataset is unseen by the model during training phase and serves exclusively the purpose of evaluation to examine the adaptability of the trained models to generalize on data unseen during training.
 
\end_layout

\begin_layout Standard
A batch-size of 
\begin_inset Formula $20$
\end_inset

 samples is used throughout all three aforementioned phases.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Note
A word on batch-size
\end_layout

\begin_deeper
\begin_layout Standard
It should be noted that the choice of batch-size has been a topic of major contention in the milieu of machine learning in general,
 with researches including 
\begin_inset CommandInset citation
LatexCommand cite
key "ml-batchsize"
literal "false"

\end_inset

 recommending smaller values up to 
\begin_inset Formula $32$
\end_inset

,
 and traditional textbooks such as 
\begin_inset CommandInset citation
LatexCommand cite
key "ml-goodfellow,ml-murphy"
literal "false"

\end_inset

 putting forward values up to hundreds.
\end_layout

\begin_layout Standard
The particular batch-size of 
\begin_inset Formula $20$
\end_inset

 as chosen in this thesis is purely decided upon via empirical observation and intuition.
 The interested reader is encourage to rerun the project code with other values for experimentation.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_body
\end_document
